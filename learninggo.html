<!DOCTYPE html>
<html>
<head>
  <title>Learning Go</title>
  <meta name="GENERATOR" content="Mmark Markdown Processor v1.0">
  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="learninggo.css">
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro|Droid+Sans' rel='stylesheet' type='text/css'>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script>
    $(document).ready(function() {
      chapters();
      appendices
      crossReferences();
      epigraphs();
    });

    function chapters(){
      $("h1:not(.appendix)").each(function(index){
        $(this).prepend("Chapter " + (index + 1) + ". ")
      })
    }

    function appendices(){
     $("h1.appendix").each(function(index){
        $(this).prepend("Appendix " + String.fromCharCode(65 + index) + ". ")
      })
    }

    // Does not work for citations that are also a ref, see Fizzbuzz.
    function crossReferences() {
      $("a:empty, [href^='#']").each(
        function(){
          var xid = $(this).attr("href");
          var val = $(xid).text();
          $(this).append(val)
        }
      );
    }

    function epigraphs() {
      $("blockquote.epigraph footer").prepend( "<hr>" );
    }

    function answers(){
      $("h3#answer").click(function() {
        $("h3#answer").nextUntil("h1,h2").toggle()
      });
    }

    function toc(){
      $("body").prepend("<div class=toc></div>");
      $("h1").each(function(){
        $("div.toc").append($(this).text()).append("<br>");
      });
    }
</script>
</head>
<body>

<h1 id="introduction">Introduction</h1>

<blockquote class="epigraph">
<p>Is Go an object-oriented language? Yes and no.</p>
<footer>&mdash; Frequently asked questions <span class="quote-who"> Go Authors
</span></footer></blockquote>

<p>The Go programming language is an open source project language to make
programmers more productive.</p>

<p>According to the website <a class="cite" href="#go_web"></a> &quot;Go is expressive, concise, clean, and
efficient&quot;. And indeed it is. My initial interest was piqued when I read early announcements about this
new language that had built-in concurreny and a C-like syntax
(Erlang also has built-in concurrency, but I could never get used to its syntax).
Go is a compiled statically typed language that feels like
a dynamically typed, interpreted language. My go to (scripting!) language Perl has taken a back seat
now that Go is around.</p>

<p>The unique Go language is defined by these principles:</p>

<dl>
<dt>Clean and Simple</dt>
<dd><p>Go strives to keep things small and beautiful. You should
be able to do a lot in only a few lines of code.</p></dd>

<dt>Concurrent</dt>
<dd><p>Go makes it easy to &quot;fire off&quot; functions to be
run as <em>very</em> lightweight threads. These threads are called
goroutines <span class="index-ref" id="idxref:0-0"></span><sup class="footnote-ref" id="fnref:Yes-that-sounds"><a class="footnote" href="#fn:Yes-that-sounds">1</a></sup> in Go.</p></dd>

<dt>Channels</dt>
<dd><p>Communication with these goroutines is done, either via shared state or
via <span class="index-ref" id="idxref:1-0"></span> channels <a class="cite" href="#csp"></a> <a class="cite" href="#hoare"></a>.</p></dd>

<dt>Fast</dt>
<dd><p>Compilation is fast and execution is fast. The aim is
to be as fast as C. Compilation time is measured in seconds.</p></dd>

<dt>Safe</dt>
<dd><p>Explicit casting and strict rules when converting one type to another.
Go has garbage collection. No more <code>free()</code> in Go: the language takes care of this.</p></dd>

<dt>Standard format</dt>
<dd><p>A Go program can be formatted in (almost) any way the programmers want,
but an official format exists. The rule is very simple:
The output of the filter <code>gofmt</code> <em>is the officially endorsed
format</em>.</p></dd>

<dt>Postfix types</dt>
<dd><p>Types are given <em>after</em> the variable name, thus <code>var a int</code>,
instead of <code>int a</code>.</p></dd>

<dt>UTF-8</dt>
<dd><p>UTF-8 is everywhere, in strings
<em>and</em> in the program code. Finally you can use <span  class="math">\(\Phi = \Phi + 1\)</span> in your source code.</p></dd>

<dt>Open Source</dt>
<dd><p>The Go license is completely open source.</p></dd>

<dt>Fun</dt>
<dd><p>Programming with Go should be fun!</p></dd>
</dl>

<p>As I mentioned Erlang also shares some
features of Go. A notable difference between Erlang
and Go is that Erlang borders on being a functional language, while Go is imperative.
And Erlang runs in a virtual machine, while Go is compiled.</p>

<h2 id="how-to-read-this-book">How to Read this Book</h2>

<p>I've written this book for people who already know some programming languages and how
to program.
In order to use this book, you (of course) need Go installed on your system, but you can easily
try examples online in the Go playground<sup class="footnote-ref" id="fnref:http-play-golang"><a class="footnote" href="#fn:http-play-golang">2</a></sup>.
All exercises in this book work with Go 1, the first stable release
of Go -- if not, it's a bug.</p>

<p>The best way to learn Go is to create your own programs.
Each chapter therefore includes exercises (and answers to exercises)
to acquaint you with the language. Each exercise
is either <em>easy</em>, <em>intermediate</em>, or <em>difficult</em>.
The answers are included after the exercises on a new page.
Some exercises don't have an answer; these are marked with an asterisk.</p>

<p>Here's what you can expect from each chapter:</p>

<dl>
<dt>Chapter <a href="#basics"></a></dt>
<dd><p>We'll look at the basic types, variables, and control structures available in the language.</p></dd>

<dt>Chapter <a href="#functions"></a></dt>
<dd><p>Here we look at functions, the basic building blocks of Go programs.</p></dd>

<dt>Chapter <a href="#packages"></a></dt>
<dd><p>We'll see that functions and data can be grouped together
in packages. We'll also see how to document and test our packages.</p></dd>

<dt>Chapter <a href="#beyond"></a></dt>
<dd><p>We'll create our own types. We'll also look at memory allocations in Go.</p></dd>

<dt>Chapter <a href="#interfaces"></a></dt>
<dd><p>We'll learn how to use interfaces. Interfaces are the central concept in Go,
as Go does not support object orientation in the traditional sense.</p></dd>

<dt>Chapter <a href="#channels"></a></dt>
<dd><p>We'll learn the <code>go</code> keyword, which can be used to start function in
separate routines (called goroutines). Communication with those goroutines is
done via channels.</p></dd>

<dt>Chapter <a href="#communication"></a></dt>
<dd><p>Finally we'll see how to interface with the rest of the world from within
a Go program. We'll see how to create files and read and write to and from them.
We'll also briefly look into networking.</p></dd>
</dl>

<h2 id="official-documentation">Official Documentation</h2>

<p>There is a substantial amount of documentation written about Go.
The Go Tutorial <a class="cite" href="#go_tutorial"></a>, the Go Tour (with lots of exercises)
and the Effective Go <a class="cite" href="#effective_go"></a> are helpful resources. The
website <a href="http://golang.org/doc/">http://golang.org/doc/</a> is a very good starting point
for reading up on Go<sup class="footnote-ref" id="fnref:http-golang-org"><a class="footnote" href="#fn:http-golang-org">3</a></sup>. Reading these documents is
certainly not required, but it is recommended.</p>

<blockquote>
<p>When searching on the internet use the term &quot;golang&quot; instead of plain &quot;go&quot;.</p>
</blockquote>

<p>Go comes with its own documentation in the form of a program called
<code>godoc</code><sup class="footnote-ref" id="fnref:When-building-fr"><a class="footnote" href="#fn:When-building-fr">4</a></sup>.
If you are interested in the documentation for the built-ins, simply do this:</p>

<pre><code>% godoc builtin
</code></pre>

<p>To get the documentation of the <code>hash</code> package, just:</p>

<pre><code>% godoc hash
</code></pre>

<p>To read the documentation of <code>fnv</code> contained in <code>hash</code>, you'll need
to issue <code>godoc hash/fnv</code> as <code>fnv</code> is a subdirectory of <code>hash</code>.</p>

<pre><code>PACKAGE DOCUMENTATION

package fnv
    import &quot;hash/fnv&quot;

    Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash
    ...
</code></pre>

<h1 id="basics">Basics</h1>

<blockquote class="epigraph">
<p>I am interested in this and hope to do something.</p>
<footer>&mdash; On adding complex numbers to Go <span class="quote-who"> Ken Thompson
</span></footer></blockquote>

<p>In this chapter we will look at the basic building blocks of the Go programming
language.</p>

<h2 id="hello-world">Hello World</h2>

<p>In the Go tutorial, you get started with Go in the typical manner: printing
&quot;Hello World&quot; (Ken Thompson and Dennis Ritchie started this when they presented
the C language in the 1970s). That's a great way to start, so here it is, &quot;Hello
World&quot; in Go.</p>

<p>
<pre><code class="language-go">package main <span class="callout">1</span>

import &quot;fmt&quot;  Implements formatted I/O. <span class="callout">2</span>

/* Print something */ <span class="callout">3</span>
func main() { <span class="callout">4</span>
	fmt.Printf(&quot;Hello, world.&quot;) <span class="callout">5</span>
}
</code></pre>
</p>

<p>Lets look at the program line by line.
This first line is just required <span class="callout">1</span>. All Go files start with
<code>package &lt;something&gt;</code>, and <code>package main</code> is required for a standalone executable.</p>

<p><code>import &quot;fmt&quot;</code> says we need <code>fmt</code> in
addition to <code>main</code> <span class="callout">2</span>. A package other than <code>main</code> is commonly called a
library, a familiar concept in many programming languages (see chapter <a href="#chap:packages"></a>.
The line ends with a comment that begins with <code>//</code>.</p>

<p>Next we another comment, but this one is enclosed in <code>/*</code> <code>*/</code> <span class="callout">3</span>.
When your Go program is executed, the first function called will be
<code>main.main()</code>, which mimics the behavior from C. Here we declare that function <span class="callout">4</span>.</p>

<p>Finally we call a function from the package <code>fmt</code> to print a
string to the screen. The string is enclosed with <code>&quot;</code> and may
contain non-ASCII characters <span class="callout">5</span>.</p>

<h2 id="compiling-and-running-code">Compiling and Running Code</h2>

<p>To build a Go program, use the <code>go</code> tool.<span class="index-ref" id="idxref:2-0"></span>
To build <code>helloworld</code> we just enter:</p>

<pre><code>% go build helloworld.go
</code></pre>

<p><span class="index-ref" id="idxref:3-0"></span>
This results in an executable called <code>helloworld</code>. <span class="index-ref" id="idxref:4-0"></span></p>

<pre><code>% ./helloworld
Hello, world.
</code></pre>

<p>You can combine the above and just call <code>go run helloworld.go</code>.</p>

<!--
\section{Variables, Types and Keywords}
\label{sec:vars}
In the next few sections we will look at the variables, basic types,
keywords, and control structures of our new language.

Go is different from (most) other languages in that the type of a variable
is specified *after* the variable name. So not:
`int a`, but `a int`. When you declare a variable it
is assigned the ``natural'' null value for the type. This means that after
`var a int`, `a` has a value of 0. With
`var s string`, `s` is assigned the zero string,
which is `""`.
Declaring and assigning in Go is a two step process, but they may
be combined. Compare the following pieces of code which have
the same effect.
(((variables,declaring)))
(((variables,assigning)))

\begin{minipage}{.5\textwidth}
\begin{lstlisting}[linewidth=.5\textwidth,numbers=none]
var a int
var b bool
a = 15
b = false
\end{lstlisting}
\hfill
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{lstlisting}[linewidth=.5\textwidth,numbers=none]


a := 15
b := false
\end{lstlisting}
\hfill
\end{minipage}

On the left we use the
\key{var} keyword to declare a variable and *then* assign a value to
it. The code on the right uses \mbox{\key{:=}{ }} to do this in one
step (this form may only be used *inside* functions).
In that case the variable
type is *deduced* from the value. A value of 15 indicates an \type{int}.
A value of `false` tells Go that the type should be \type{bool}.
Multiple \key{var} declarations may also be grouped; \key{const} (see ``\nameref{sec:constants}'')
and \key{import} also allow this. Note the use of parentheses instead of braces:
\begin{lstlisting}[numbers=none]
var (
    x int
    b bool
)
\end{lstlisting}
Multiple variables of the same type can also be declared on a
single line: `var x, y int` makes `x` and `y` both
\type{int} variables. You can also make use of \first{parallel
assignment}{parallel assignment}: `a, b := 20, 16`.
This makes `a` and `b` both integer variables and assigns
20 to `a` and 16 to `b`.

A special name for a variable is `\textbf{\_`} (((variables,_)))
(underscore)(((variables,underscore))). Any value
assigned to it is discarded (it's similar to \file{/dev/null} on Unix). In this example we only assign the integer
value of 35 to `b` and discard the value 34: `_, b := 34, 35`.
Declared but otherwise *unused* variables are a compiler error in Go.

\subsection{Boolean Types}
A boolean type represents the set of boolean truth values denoted by the
predeclared constants *true* and *false*. The boolean type is \type{bool}.

\subsection{Numerical Types}
Go has most of the well-known types such as `int`. The `int` type
has the appropriate length for your machine,
meaning that on a 32-bit machine it is 32 bits and on
a 64-bit machine it is 64 bits. Note: an `int` is
either 32 or 64 bits, no other values are defined. Same goes
for `uint`, the unsigned int.

If you want to be explicit about the length, you can have that too,
with \type{int32}, or \type{uint32}. The full
list for (signed and unsigned) integers is
\type{int8}, \type{int16}, \type{int32}, \type{int64} and
\type{byte}, \type{uint8}, \type{uint16}, \type{uint32}, \type{uint64},
with `byte` being an
alias for `uint8`. For floating point values there is
\type{float32} and \type{float64} (there is no `float` type).
A 64 bit integer or floating point value is *always* 64 bit, also on 32 bit
architectures.

Note
that these types are all distinct and assigning variables which mix
these types is a compiler error, like in the following code:
\lstinputlisting[label=src:types,numbers=none]{src/basics/types.go}

We declare two different integers, a and b where a is an \type{int} and
b is an \type{int32}. We want to set b to the sum of a and a. This
fails and gives the error:
\error{cannot use a + a (type int)  as type int32 in assignment}.
Adding the constant 5 to b *does* succeed, because constants are
not typed.

\subsection{Constants}
\label{sec:constants}
Constants in Go are just that --- constant. They are created at compile
time, and can only be numbers, strings, or booleans;
`const x = 42` makes `x` a constant. You can use
\first{\key{iota}}{keyword!iota} \footnote{The word [iota] is used in a common English phrase,
'not one iota', meaning 'not the slightest difference', in reference to
a phrase in the New Testament: ``\emph{until heaven and earth pass away, not an
iota, not a dot, will pass from the Law}.'' \cite{iota}}
to enumerate values.
\begin{lstlisting}[numbers=none]
const (
    a = iota
    b
)
\end{lstlisting}
The first use of \key{iota} will yield 0, so `a` is equal to 0. Whenever
\key{iota} is used again on a new line its value is incremented with 1, so `b`
has a value of 1. Or, as shown here, you can even let Go repeat the use of \key{iota}.
You may also explicitly type a constant: `const b string = "0"`. Now
`b` is a \type{string} type constant.

\subsection{Strings}
Another important built-in type is `string`. Assigning a
string is as simple as:
\begin{lstlisting}[numbers=none]
s := "Hello World!"
\end{lstlisting}
Strings in Go are a sequence of UTF-8 characters enclosed in double
quotes ("). If you use the single quote (') you mean one character
(encoded in UTF-8) --- which is *not* a `string` in Go.

Once assigned to a variable, the string cannot be changed: strings in Go are
immutable. If you are coming from C, not that the following is not legal in Go:
\begin{lstlisting}[numbers=none]
var s string = "hello"
s[0] = 'c'
\end{lstlisting}
To do this in Go you will need the following:
\begin{lstlisting}[numbers=none]
s := "hello"
c := []rune(s)      |\longremark{Here we convert `s` to an array of runes \citem.}|
c[0] = 'c'      |\longremark{We change the first element of this array \citem.}|
s2 := string(c)     |\longremark{Then we create a *new* string `s2` with the alteration \citem.}|
fmt.Printf("%s\n", s2) |\longremark{Finally, we print the string with `fmt.Printf` \citem.}|
\end{lstlisting}
\showremarks

%% remove this section.
%%Due to the insertion of semicolons (see \cite{effective_go} section
%%``Semicolons''), you need to be careful with using multi line strings. If
%%you write:
%%\begin{lstlisting}[numbers=none]
%%s := "Starting part"
%%    + "Ending part"
%%\end{lstlisting}
%%This is transformed into:
%%\begin{lstlisting}[numbers=none]
%%s := "Starting part";
%%    + "Ending part";
%%\end{lstlisting}
%%Which is not valid syntax, you need to write:
%%\begin{lstlisting}[numbers=none]
%%s := "Starting part" +
%%     "Ending part"
%%\end{lstlisting}
%%Then Go will not insert the semicolons in the wrong places. Another way
%%would be to use *raw* string literals(((string literal,raw))) by using backquotes (\key{`}):
%%\begin{lstlisting}[numbers=none]
%%s := `Starting part
%%     Ending part`
%%\end{lstlisting}
%%Be aware that in this last example `s` now also contains the newline.
%%Unlike *interpreted* string literals (((string literal,interpreted))) the value of a raw string literal
%%is composed of the *uninterpreted* characters between the quotes.

\subsection{Runes}
`Rune` is an alias for \type{int32}. It is an UTF-8 encoded code point. When is this type useful?
One example is when you're
iterating over characters in a string. You could loop over each byte (which is only equivalent to a character
when strings are encoded in 8-bit ASCII, which they are *not* in Go!). But to get the actual characters you
should use the \type{rune} type.

\subsection{Complex Numbers}
Go has native support for complex numbers. To
use them you need a variable of type \type{complex128} (64
bit real and imaginary parts) or \type{complex64} (32 bit
real and imaginary parts).
Complex numbers are written as
`re + im$$i$$`, where `re` is the real part,
`im` is the imaginary part and $$i$$ is the literal '$$i$$' ($$\sqrt{-1}$$).

\subsection{Errors}
Any non-trivial program will have the need for error reporting sooner or later. Because of this
Go has a builtin type specially for errors, called \type{error}.
`var e error` creates a variable `e` of type \type{error} with the
value `nil`. This error type is an interface -- we'll look more at interfaces in Chapter
``\ref{chap:interfaces}''. For now you can just assume that \type{error} is a type just like all other types.

\section{Operators and Built-in Functions}
\label{sec:builtins}
Go supports the normal set of numerical operators.
Table \ref{tab:op-precedence}
lists the current ones and their relative precedence. They
all associate from left to right.

\begin{table}[Hh!]
\begin{center}
\caption{Operator precedence}
\label{tab:op-precedence}
\input{tab/precedence.tex}
\end{center}
\end{table}
\verb|+ - * /| and \verb|%| all do what you would expect,
\verb!& | ^!
and \verb!&^! are bit operators for
\first{bitwise *and*}{operator!bitwise!and},
\first{bitwise *or*}{operator!bitwise!or}, \first{bitwise *xor*}{operator!bit
wise xor}, and \first{bit clear}{operator!bitwise!clear} respectively.
The \verb|&&| and \verb/||/ operators are
logical \first{*and*}{operator!and} and
logical \first{*or*}{operator!or}. Not listed in the table
is the logical \first{not}{operator!not}: \verb/!/

Although Go does not support operator overloading (or method
overloading for that matter), some of the built-in
operators *are* overloaded. For instance, `+` can be used for integers,
floats, complex numbers and strings (adding strings is concatenating them).

\section{Go Keywords}
Let's start looking at keywords. Table \ref{tab:keywords} lists all the keywords in Go.
\begin{table}[Hh!]
\begin{center}
\caption{Keywords in Go}
\label{tab:keywords}
\input{tab/keywords.tex}
\end{center}
\end{table}
We've seen some of these already. We used \key{var} and \key{const} in the
``\nameref{sec:vars}'' section on page \pageref{sec:vars}, and we briefly looked at \key{package} and \key{import} in our "Hello World" program at the start of the chapter.
Others need more attention and have their own chapter or section:
\begin{itemize}
\item \key{func} is used to declare functions and methods.
\item \key{return} is used to return from functions. We'll look at both \key{func} and \key{return} in detail in Chapter \ref{chap:functions}.
\item \key{go} is used for concurrency. We'll look at this in Chapter \ref{chap:channels}.
\item \key{select} used to choose from different types of communication, We'll work with \key{select} in Chapter \ref{chap:channels}.
\item \key{interface} is covered in Chapter \ref{chap:interfaces}.
\item \key{struct} is used for abstract data types. We'll work with \key{struct} in Chapter \ref{chap:beyond}.
\item \key{type} is also covered in Chapter \ref{chap:beyond}.
\end{itemize}

\section{Control Structures}
There are only a few control structures in Go. To write loops we use the \key{for} keyword, and there is a
\key{switch} and of course an \key{if}. When working with channels \key{select} will be used (see Chapter \ref{chap:channels}).
Parentheses are are not required around the condition, and the body must *always* be brace-delimited.

\subsection{If-Else}
In Go an \first{\key{if}}{keyword!if} looks like this:
\begin{lstlisting}
if x > 0 {
    return y
} else {
    return x
}
\end{lstlisting}

(((keyword,return)))

(((keyword,if))) (((keyword,else)))
Since \key{if} and \key{switch} accept an initialization statement, it's common to
see one used to set up a (local) variable.
\begin{lstlisting}[numbers=none]
if err := SomethingFunction(); err == nil {
    // do something
} else {
    return err
}
\end{lstlisting}

It is idomatic in Go to omit the \key{else} when the \key{if} statement's body has a \key{break}, \key{continue}, \key{return} or,
\key{goto}, so the above code would be better written as:
\begin{lstlisting}[numbers=none]
if err := SomethingFunction(); err != nil {
    return err
}
// do something
\end{lstlisting}
The opening brace on the first line must be positioned on the same line as the \key{if} statement. There is no
arguing about this, because this is what `gofmt` outputs.

\subsection{Goto}
Go has a \first{\key{goto}}{keyword!goto} statement --- use it wisely. With \key{goto}
you jump to a (((label))) label which must be defined within the current function.
For instance, a loop in disguise:
\begin{lstlisting}[numbers=none]
func myfunc() {
        i := 0
Here:
        fmt.Println(i)
        i++
        goto Here
}
\end{lstlisting}
The string `Here:` indicates a label. A label does not need to start with a capital letter and is case sensitive.

\subsection{For}
\label{sec:for}
The Go \first{\key{for}}{keyword!for} loop has three forms, only one of
which has semicolons:
\begin{itemize}
    \item \lstinline|for init; condition; post { }| -- a loop using the syntax borrowed from C;
    \item \lstinline|for condition { }| -- a while loop, and;
    \item \lstinline|for { }| -- an endless loop.
\end{itemize}
Short declarations make it easy to declare the index variable right in the loop.
\begin{lstlisting}[numbers=none]
sum := 0
for i := 0; i < 10; i++ {
    sum = sum + i
}
\end{lstlisting}
Note that the variable `i` ceases to exist after the loop.

\subsection{Break and Continue}
With \first{\key{break}}{keyword!break} you can quit loops early.  By itself, \key{break} breaks
the current loop.
\begin{lstlisting}[numbers=none]
for i := 0; i < 10; i++ {
    if i > 5 {
    break|\longremark{Here we \key{break} the current loop \citem, and don't continue with the `fmt.Println(i)` statement \citemnext.}|
    }
    fmt.Println(i)|\longremark{So we only print 0 to 5. With loops within loop you can specify a label after \key{break} to identify *which* loop to stop:}|
}
\end{lstlisting}
\showremarks

\begin{lstlisting}[numbers=none]
J:  for j := 0; j < 5; j++ { |\longremark{Here we define a label "J" \citem, preceding the \key{for}-loop there.}|
        for i := 0; i < 10; i++ {
            if i > 5 {
                break J |\longremark{When we use \key{break J} \citem, we don't break the inner loop but the "J" loop.}|
            }
            fmt.Println(i)
        }
    }
\end{lstlisting}
\showremarks

With \first{\key{continue}}{keyword!continue} you begin the next iteration of the
loop, skipping any remaining code. In the same way as \key{break},
\key{continue} also accepts a label.

\subsection{Range}
The keyword \first{\key{range}}{keyword!range} can be used for loops. It
can loop over slices, arrays, strings, maps and channels (see Chapter
\ref{chap:channels}). \key{range} is
an iterator that, when called, returns the next key-value pair from the "thing" it
loops over. Depending on what that is, \key{range} returns different things.

When looping over a slice or array, \key{range} returns the index in the
slice as the key and value belonging to that index.
Consider this code: (((keyword,range)))
\begin{lstlisting}[numbers=none]
list := []string{"a", "b", "c", "d", "e", "f"}
for k, v := range list {
    // do something with k and v
}
\end{lstlisting}
First we create a slice of strings. Then we use \key{range} to loop over them. With each iteration, \key{range} will return the index as an \type{int} and the key as a \type{string}.
It will start with 0 and "a", so `k` will be 0 through 5, and v will be "a" through "f".

You can also use \key{range} on strings directly. Then it
will break out the individual Unicode characters
\footnote{In the UTF-8 world characters are sometimes called \first{runes}{runes}.
Mostly, when people talk about
characters, they mean 8 bit characters. As UTF-8 characters may be up to 32 bits the word
rune is used. In this case the type of `char` is \type{rune}.} and their start position, by parsing the UTF-8.
The loop: (((keyword,range)))
\begin{lstlisting}[numbers=none]
for pos, char := range "a|$\Phi{}$|x" {
    fmt.Printf("character '%c' starts at byte position %d\n", char, pos)
}
\end{lstlisting}
prints
\begin{alltt}
character 'a' starts at byte position 0
character '\begin{math}\Phi\end{math}' starts at byte position 1
character 'x' starts at byte position 3
\end{alltt}
Note that '\begin{math}\Phi\end{math}' took 2 bytes, so 'x' starts at byte 3.

\subsection{Switch}
Go's \first{\key{switch}}{keyword!switch} is very flexible; you can match on much more than just
integers.
The cases are evaluated top to bottom until
a match is found, and if the \key{switch} has no expression it switches on
\type{true}. It's therefore possible -- and idiomatic -- to write an
\key{if-else-if-else} chain as a \key{switch}.
\begin{lstlisting}[numbers=none]
// Convert hexadecimal character to an int value
switch { |\longremark{A \key{switch} without a condition is the same as \key{switch true} \citem.}|
case '0' <= c && c <= '9':|\longremark{We list the different cases. Each \key{case} statement has a condition that is either %
true of false. Here \citem{} we check if `c` is a number.}|
    return c - '0'|\longremark{If `c` is a number we return its value \citem.}|
case 'a' <= c && c <= 'f':|\longremark{Check if `c` falls between ``a'' and ``f'' \citem. For an ``a'' we return 10, for ``b'' we return 11, etc. We also do the same \citemnext{} thing for ``A'' to ``F''.}|
    return c - 'a' + 10
case 'A' <= c && c <= 'F':|\longremarkempty|
    return c - 'A' + 10
}
return 0
\end{lstlisting}
\showremarks

There is no automatic fall through, you you can use
\first{\key{fallthrough}}{keyword!fallthrough} for that.
\begin{lstlisting}[numbers=none]
switch i {
    case 0:  fallthrough
    case 1: |\longremark{`f()` can be called when \code{i == 0} \citem.%
With \first{\key{default}}{keyword!default} you can specify an action%
when none of the other cases match.}|
        f()
    default:
        g() |\longremark{Here `g()` is called when `i` is not 0 or 1 \citem.}|

\end{lstlisting}
\showremarks
We could rewrite the above example as:
\begin{lstlisting}[numbers=none]
switch i {
    case 0, 1:|\longremark{You can list cases on one line \citem, separated by commas.}|
        f()
    default:
        g()
\end{lstlisting}
\showremarks

\section{Built-in Functions}
A few functions are predefined, meaning
you *don't* have to include any package to get
access to them. Table \ref{tab:predef-functions} lists them all.\footnote{You can use the
command `godoc builtin` to read the online documentation about the built-in types and functions.}

\begin{table}[Hh!]
\begin{center}
\caption{Pre--defined functions in Go}
\label{tab:predef-functions}
\input{tab/functions.tex}
\end{center}
\end{table}

These built-in functions are documented in the \package{builtin} (((package,builtin)))
pseudo package that is included in recent Go releases. Let's go over these functions briefly.

\begin{description}
\item[`close`] is used in
channel communication. It closes a channel. We'll learn more about this in Chapter \ref{chap:channels}.
(((built-in,close)))

\item[`delete`] is used for deleting entries in maps.
(((built-in,delete)))

\item[`len` and `cap`] are used on a number of different
types, `len` is
used to return the lengths of strings, slices, and
arrays. In the next section \nref{sec:arrays} we'll look at slices,
arrays and the function
`cap`.(((built-in,len)))(((built-in,cap)))

\item[`new`] is used for allocating memory for user defined
data types. See \nref{sec:allocation with new} on page
\pageref{sec:allocation with new}.
(((built-in,new)))

\item[`make`] is used for allocating memory for built-in
types (maps, slices, and channels). See \nref{sec:allocation with make} on page
\pageref{sec:allocation with make}.
(((built-in,make)))

\item[`copy`] is for copying slices. See \nref{sec:slices} section in this chapter.
(((built-in,copy)))

\item[`append`] is for concatenating slices.
See \nref{sec:slices} in this chapter.
(((built-in,append)))

\item[`panic`, `recover`] are used for an
*exception* mechanism. See \nref{sec:panic} on page \pageref{sec:panic} for more.
(((built-in,panic)))
(((built-in,recover)))

\item[`print`, `println`] are low level printing
functions that can be used without reverting to the
\package{fmt}(((package,fmt)))
package. These are mainly used for debugging.
(((built-in,print)))(((built-in,println)))

\item[`complex`, `real`, `imag`] all deal with
\first{complex numbers}{complex numbers}. We will not use complex numbers in this book.
(((built-in,complex)))
(((built-in,real)))
(((built-in,imag)))
\end{description}

\section{Arrays, Slices, and Maps}
\label{sec:arrays}
To store multiple values in a list, you can use arrays, or
their more flexible cousin: slices. A dictionary or hash type is also
available. It is called a \type{map} in Go.

\subsection{Arrays}
An array is defined by: \verb|[n]<type>|, where $n$ is the length
of the array and \verb|<type>| is the stuff you want to store.
To assign or index an element in the array, you use square brackets:
\begin{lstlisting}[numbers=none]
var arr [10]int
arr[0] = 42
arr[1] = 13
fmt.Printf("The first element is %d\n", arr[0])
\end{lstlisting}
Array types like `var arr [10]int` have a fixed size. The
size is *part* of the type.
They can't grow, because then they would have a different type. Also arrays
are values: Assigning one array to another *copies* all the elements.
In particular, if you pass an array to a function it will receive a
copy of the array, not a pointer to it.

(((array,multidimensional)))
To declare an array you can use the following: `var a [3]int`.
To initialize it to something other than zero, use a
\first{composite literal}{literal!composite}: \lstinline|a := [3]int{1, 2, 3}|.
This can be shortened to \lstinline|a := [...]int{1, 2, 3}|, where Go counts
the elements automatically.

\gomarginpar{A composite literal allows you
to assign a value directly to an array, slice, or map.
See \nref{sec:constructors and composite literals} on
page \pageref{sec:constructors and composite literals} for more information.}
When declaring arrays you *always* have to type something in
between the square brackets, either a number or three dots (\verb|...|),
when using a composite literal.
When using multidimensional arrays, you can use the following syntax:
\lstinline|a := [2][2]int{ {1,2}, {3,4} }|. Now that you know about arrays you will
be delighted to learn that you will almost never use them in Go, because there is something
much more flexible: slices.
-->

<h3 id="slices">Slices</h3>

<p>A slice is similar to an array, but it can grow when new elements are added.
A slice always refers to an underlying array. What makes slices different
from arrays is that a slice is a pointer <em>to</em> an array;
slices are reference types.<span class="index-ref" id="idxref:5-0"></span></p>

<aside>
<p>Reference types are created with <code>make</code>. We detail this further
in Chapter <a href="#chap:beyond"></a>.</p>
</aside>

<p>That means that if you assign one slice to
another, both refer to the <em>same</em> underlying array. For instance, if a
function takes a slice argument, changes it makes to the elements of the
slice will be visible to the caller, analogous to passing a pointer to
the underlying array. With: <code>slice := make([]int, 10)</code>,
you create a slice which can hold ten elements. Note that the
underlying array isn't specified.
A slice is always coupled to an array that has
a fixed size. For slices we define a capacity <span class="index-ref" id="idxref:6-0"></span> and a
length <span class="index-ref" id="idxref:7-0"></span>.
Figure (fig:array-vs-slice) shows the creation of an array, then the creation of a slice.
First we create an array of <span  class="math">\(m\)</span> elements of the type <code>int</code>: <code>var array[m]int</code> .</p>

<p>Next, we create a slice from this array: <code>slice := array[:n]</code> .
And now we have:</p>

<ul>
<li><code>len(slice) == n</code></li>
<li><code>cap(slice) == m</code></li>
<li><code>len(array) == cap(array) == m</code></li>
</ul>

<p><figure><img src="fig/array-vs-slice.png" alt="Array versus slice" title="An array versus a slice.">
<figcaption>An array versus a slice.</figcaption></figure></p>

<p>Given an array, or another slice, a new slice is created via
<code>a[n:m]</code>. This creates a new slice which refers to the variable <code>a</code>, starts at index <code>n</code>, and ends
before index <code>m</code>. It has length <code>n - m</code>.</p>

<pre><code>a := [...]int{1, 2, 3, 4, 5} <span class="callout">1</span>
s1 := a[2:4] <span class="callout">2</span>
s2 := a[1:5] <span class="callout">3</span>
s3 := a[:]   <span class="callout">4</span>
s4 := a[:4]  <span class="callout">5</span>
s6 := a[2:4:5] <span class="callout">6</span>
</code></pre>

<!-- Double check this -->

<p>First we define <span class="callout">1</span> an array with five elements, from index 0 to 4.
From this we create <span class="callout">2</span> a slice with the elements from index 2 to 3, this slices contains: <code>3, 4</code>.
Then we we create another slice <span class="callout">3</span> from <code>a</code>: with the elements from index 1 to 4,
this contains: <code>2, 3, 4, 5</code>.
With <code>a:[:]</code> <span class="callout">4</span> we create a slice with of all the elements in the array. This is a shorthand for: <code>a[0:len(a)]</code>.
And with <code>a[:4]</code> <span class="callout">5</span> we create a slice with the elements from index
0 to 3, this is short for: <code>a[0:4]</code>, and gives us a slices that contains: <code>1, 2, 3, 4</code>.
With <code>s2[:]</code> we create a slice from the slice <code>s2</code> <span class="callout">6</span>, note that <code>s5</code> still refers to the array <code>a</code>.
Finally, we create a slice with the elements from index 3 to 3 <em>and</em> also set the cap to 4 <span class="callout">6</span>.</p>

<p>When working with slices you can overrun the bounds, consider this code.</p>

<p>
<pre><code class="language-go">package main

func main() {
	var array [100]int   <span class="callout">1</span>
	slice := array[0:99] <span class="callout">2</span>

	slice[98] = 1 <span class="callout">3</span>
	slice[99] = 2 <span class="callout">4</span>
}
</code></pre>

At <span class="callout">1</span> we create an array with a 100 elements, indexed from 0 to 99.
Then at <span class="callout">2</span> we create a slice that has index 0 to 98.
We assign 1 to the 99th element <span class="callout">3</span> of the slice. This works as expected.
But at <span class="callout">4</span> we dare to do the impossible, and and try to allocate something
beyond the length of the slice and we are greeted with a <em>runtime</em> error: <code>Error: &quot;throw: index out of range&quot;.</code></p>

<p>If you want to extend a slice, there are a couple of built-in functions
that make life easier:
<code>append</code> and <code>copy</code>.
The append function appends zero or more values to a slice and returns the result: a slice with the same type as the original. If the original slice isn't big enough to fit the added values, append will allocate a new slice that is big enough. So the slice returned by append may refer to a different underlying array than the original slice does.
Here's an example: <span class="index-ref" id="idxref:8-0"></span></p>

<pre><code>s0 := []int{0, 0}
s1 := append(s0, 2) <span class="callout">1</span>
s2 := append(s1, 3, 5, 7) <span class="callout">2</span>
s3 := append(s2, s0...) <span class="callout">3</span>
</code></pre>

<p>At <span class="callout">1</span> we append a single element, making <code>s1</code> equal to <code>[]int{0, 0, 2}</code>.
At <span class="callout">2</span> we append multiple elements, making <code>s2</code> equal to <code>[]int{0, 0, 2, 3, 5, 7}</code>.
And at <span class="callout">3</span> we append a slice, giving us <code>s3</code> equal to <code>[]int{0, 0, 2, 3, 5, 7, 0, 0}</code>.
Note the three dots used after <code>s0...</code>! This is needed make it clear explicit that you're
appending another slice, instead of a single value.</p>

<p>The copy function copies slice elements from a source to a destination, and returns the number of elements it copied. This number is the minimum of the length of the source and the length of the destination.
For example:
<span class="index-ref" id="idxref:9-0"></span></p>

<pre><code>var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
n1 := copy(s, a[0:])  <span class="callout">1</span>
n2 := copy(s, s[2:])  <span class="callout">2</span>
</code></pre>

<p>After <span class="callout">1</span>, <code>n1</code> is 6, and <code>s</code> is <code>[]int{0, 1, 2, 3, 4, 5}</code>.
And after <span class="callout">2</span>, <code>n2</code> is 4, and <code>s</code> is <code>[]int{2, 3, 4, 5, 4, 5}</code>.</p>

<!--
\subsection{Maps}
\label{sec:maps}
Many other languages have a type similar to maps built-in. For instance, Perl has hashes,
Python has its dictionaries, and C++ also has maps (as part of the libraries).
In Go we have the
\first{\key{map}}{keyword!map} type. A \type{map} can be thought of as an array indexed by
strings (in its most simple form).

\begin{lstlisting}[numbers=none]
monthdays := map[string]int{
    "Jan": 31, "Feb": 28, "Mar": 31,
    "Apr": 30, "May": 31, "Jun": 30,    |\longremark{The general syntax for defining a map is {\tt map[<from type>]<to type>}. %
Here, we define a map that converts from a \key{string} (month abbreviation) to an \type{int} (number of days in that month). Note that the trailing comma at %
\citem{} is *required*.}|
    "Jul": 31, "Aug": 31, "Sep": 30,
    "Oct": 31, "Nov": 30, "Dec": 31,
}
\end{lstlisting}
\showremarks

Use \key{make} when only declaring a map:
\lstinline|monthdays := make(map[string]int)|. A map is a reference type.

For indexing ("searching") the map, we use square brackets. For example,
suppose we want to print the
number of days in December:\newline %% the code will overflow otherwise
\noindent`fmt.Printf("%d\n", monthdays["Dec"])`

If you are looping over an array, slice, string, or map a,
\first{\key{range}}{keyword!range}
clause will help you again, it returns the key and corresponding value
with each invocation.(((keyword,range)))
\begin{lstlisting}
year := 0
for _, days := range monthdays |\longremark{At \citem{} we use the underscore to ignore (assign to nothing) the key returned by \key{range}. %
We are only interested in the values from `monthdays`.}|
    year += days
}
fmt.Printf("Numbers of days in a year: %d\n", year)
\end{lstlisting}
\showremarks

(((keyword,map adding elements)))
To add elements to the map, you would add new month with: \lstinline|monthdays["Undecim"] = 30|. If you use a key that
already exists, the value will be silently overwritten: \lstinline|monthdays["Feb"] = 29|.
To test for existence (((keyword,map existence))), you would use the
following: `value, present := monthdays["Jan"]`. If the key "Jan" exists, `present`
will be true. It's more Go like to name `present` "ok", and use:
`v, ok := monthdays["Jan"]`. In Go we call this the "comma ok" form.

You can remove elements (((keyword,map remove elements))) from the \type{map}:
`delete(monthdays, "Mar")`\footnote{Always rainy in March anyway.}.
In general the syntax `delete(m, x)` will delete the map entry
retrieved by the expression `m[x]`.
-->

<h2 id="exercises">Exercises</h2>

<h2 id="forloop" class="exersice" difficulty="0">For-loop</h2>

<ol>
<li><p>Create a loop with the <code>for</code> construct. Make it loop
10 times and print out the loop counter with the <code>fmt</code> package.</p></li>

<li><p>Rewrite the loop from to use <code>goto</code>. The keyword <code>for</code> may not be used.</p></li>

<li><p>Rewrite the loop again so that it fills an array and then prints that array to the screen.</p></li>
</ol>

<h3 id="answer" class="answer">Answer</h3>

<ol>
<li><p>There are many possibilities. One solutions could be:

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(&quot;%d&quot;, i)
	}
}
</code></pre>

Let's compile this and look at the output.</p>

<pre><code>% go build for.go
% ./for
0
1
.
.
.
9
</code></pre></li>

<li><p>Rewriting the loop results in code that should look something
like this (only showing the <code>main</code>-function):</p></li>
</ol>

<pre><code>    func main() {
            i := 0  <span class="callout">1</span>
    Loop:           <span class="callout">2</span>
            fmt.Printf(&quot;%d\n&quot;, i)
            if i &lt; 10 {
                i++ 
                goto Loop <span class="callout">3</span>
            }   
    }

At <span class="callout">4</span> we define our loop variable. And at <span class="callout">5</span> we define a label and at <span class="callout">6</span> we jump
to this label.
</code></pre>

<ol>
<li><p>The following is one possible solution:


<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
   var arr [10]int <span class="callout">1</span>
   for i := 0; i &lt; 10; i++ {
       arr[i] = i <span class="callout">2</span>
   }
   fmt.Printf(&quot;%v&quot;, arr) <span class="callout">3</span>
}
</code></pre>
</p>

<p>Here <span class="callout">1</span> we create an array with 10 elements.
Which we then fill <span class="callout">2</span> one by one. And finally we print it <span class="callout">3</span> with <code>%v</code> which lets
Go to print the value for us. You could even do this in one fell swoop by using a composite literal:</p>

<pre><code>fmt.Printf(&quot;%v\n&quot;, [...]int{0,1,2,3,4,5,6,7,8,9})
</code></pre></li>
</ol>

<h2 id="average" class="exercise" difficulty="1">Average</h2>

<ol>
<li>Write code to calculate the average of a <code>float64</code> slice. In
a later exercise you will make it into a function.</li>
</ol>

<h3 id="answer-1" class="answer">Answer</h3>

<ol>
<li>The following code calculates the average.</li>
</ol>

<pre><code>sum := 0.0 
switch len(xs) {
case 0: <span class="callout">1</span> 
        avg = 0
default: <span class="callout">2</span>
        for _, v := range xs {
                sum += v
        }
        avg = sum / float64(len(xs)) <span class="callout">3</span>
}
</code></pre>

<p>Here at <span class="callout">1</span> we check if the length is zero and if so, we return 0.
Otherwise we calculate the average at <span class="callout">2</span>.
We have to convert the value return from <code>len</code> to a <code>float64</code>
to make the division work at <span class="callout">3</span>.</p>

<h2 id="fizzbuzz" class="exercise," difficulty="0">FizzBuzz</h2>

<ol>
<li>Solve this problem, called the Fizz-Buzz <a class="cite" href="#fizzbuzz"></a> problem:</li>
</ol>

<p>Write a program that prints the numbers from 1 to 100. But for multiples
of three print, &quot;Fizz&quot; instead of the number, and for multiples of
five, print &quot;Buzz&quot;. For numbers which are multiples of both three and
five, print &quot;FizzBuzz&quot;.</p>

<h3 id="answer-2">Answer</h3>

<ol>
<li>A possible solution to this problem is the following program.</li>
</ol>

<p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	const (
		FIZZ = 3 <span class="callout">1</span>
		BUZZ = 5
	)
	var p bool  <span class="callout">2</span>
	for i := 1; i &lt; 100; i++ { <span class="callout">3</span>
		p = false
		if i%FIZZ == 0 { <span class="callout">4</span>
			fmt.Printf(&quot;Fizz&quot;)
			p = true
		}
		if i%BUZZ == 0 { <span class="callout">5</span>
			fmt.Printf(&quot;Buzz&quot;)
			p = true
		}
		if !p { <span class="callout">6</span>
			fmt.Printf(&quot;%v&quot;, i)
		}
		fmt.Println()
	}
}
</code></pre>
</p>

<p>Here <span class="callout">1</span> we define two constants to make our code more readable, see <a href="#constants"></a>.
At <span class="callout">2</span> we define a boolean that keeps track if we already printed something.
At <span class="callout">3</span> we start our for-loop, see <a href="#for"></a>.
If the value is divisible by FIZZ - that is, 3 - , we print &quot;Fizz&quot; <span class="callout">4</span>.
And at <span class="callout">5</span> we check if the value is divisble by BUZZ -- that is, 5 -- if so print
&quot;Buzz&quot;. Note that we have also taken care of the FizzBuzz case.
At <span class="callout">6</span>, if printed neither Fizz nor Buzz printed, we print the value.</p>

<h1 id="functions">Functions</h1>

<blockquote class="epigraph">
<p>I'm always delighted by the light touch and stillness of
early programming languages.  Not much text; a lot gets
done. Old programs read like quiet conversations
between a well-spoken research worker and a well-
studied mechanical colleague, not as a debate with a
compiler.  Who'd have guessed sophistication bought
such noise?</p>
<footer><span class="quote-who"> Richard P. Gabriel
</span></footer></blockquote>

<p>Functions are the basic building blocks of Go programs; all interesting
stuff happens in them.</p>

<p>Here is an example of how you can declare a function:</p>

<pre><code>type mytype int
func (p mytype) funcname(q int) (r,s int) { return 0,0 }
 <span class="callout">1</span>        <span class="callout">2</span>        <span class="callout">3</span>      <span class="callout">4</span>        <span class="callout">5</span>         <span class="callout">6</span>
</code></pre>

<p>To declare a function, you use the <code>func</code> keyword <span class="callout">1</span>.
You can optionally bind <span class="callout">2</span> to a specific type called receiver <span class="index-ref" id="idxref:10-0"></span> (a function with a receiver is
usually called an method <span class="index-ref" id="idxref:11-0"></span>. This will be explored in Chapter <a href="#interfaces"></a>.
Next <span class="callout">3</span> you write the name of your function.
Here <span class="callout">4</span> we define that the variable <code>q</code> of type <code>int</code> is
the input parameter. Parameters are passed <em>pass-by-value</em>.<span class="index-ref" id="idxref:12-0"></span>
The variables <code>r</code> and <code>s</code> <span class="callout">5</span> are the <em>named return parameters</em>
<span class="index-ref" id="idxref:13-0"></span> for this function. Functions in Go can
have multiple return values. This is very useful to return a value <em>and</em> and
error. This removes the need for in-band error returns (such as -1 for <code>EOF</code>)
and modifying an argument.
If you want the return
parameters not to be named you only give the types: <code>(int, int)</code>. If you have only one value to return you may omit
the parentheses. If your function is a subroutine and does not have anything to
return you may omit this entirely.
Finally, we have the body <span class="callout">6</span> of the function. Note that <code>return</code> is a statement so the braces around the parameter(s) are optional.</p>

<p>As said the return or result parameters of a Go function can be given names and used
as regular variables, just like the incoming parameters. When named, they are
initialized to the zero values for their types when the function begins. If the
function executes a <code>return</code> statement with no arguments, the current values of
the result parameters are returned. Using these
features enables you (again) to do more with less code.<sup class="footnote-ref" id="fnref:This-is-a-motto"><a class="footnote" href="#fn:This-is-a-motto">5</a></sup></p>

<p>The names are not mandatory but they can make code shorter and clearer:
<em>they are documentation</em>. However don't overuse this features, especially in
longer function where it might not be immediately apperent what is returned.</p>

<p>Functions can be declared in any order you wish. The compiler scans the
entire file before execution, so function prototyping is a thing of the
past in Go. Go does not allow nested functions, but you can work around this with
anonymous functions. See the Section
<a href="#functions-as-values"></a> in this chapter.
Recursive functions work just as in other languages:</p>

<pre><code>func rec(i int) {
   if i == 10 { <span class="callout">1</span>
        return
   }
   rec(i+1) <span class="callout">2</span>
   fmt.Printf(&quot;%d &quot;, i)
}
</code></pre>

<p>Here <span class="callout">2</span> we call the same function again, <code>rec</code> returns when <code>i</code> has the value 10, this
is checked on the second line <span class="callout">1</span>. This function prints: <code>9 8 7 6 5 4 3 2 1 0</code>, when called as <code>rec(0)</code>.</p>

<h2 id="scope">Scope</h2>

<p>Variables declared outside any functions are <em>global</em> <span class="index-ref" id="idxref:14-0"></span> in Go, those
defined in functions are <em>local</em> <span class="index-ref" id="idxref:15-1"></span> to those functions. If names overlap --- a
local variable is declared with the same name as a global one --- the
local variable hides the global one when the current function is
executed.</p>

<p>In the following example we call <code>g()</code> from <code>f()</code>:</p>

<pre><code>package main

var a int

func main() {
        a = 5
        print(a)
        f()
}

func f() {
        a := 6
        print(a)
        g()
}

func g() {
        print(a)
}
</code></pre>

<p>On line 3 we declare <code>a</code> to be a global variable of type <code>int</code>. Then in the
<code>main</code> function we give the <em>global</em> <code>a</code> the value of 5, after printing it we
call the function <code>f</code>. Then on line 12 <code>a := 6</code>, we create a <em>new, local</em> variable
also called <code>a</code>. This new <code>a</code> gets the value of 6, which we then print. Then we call <code>g</code>,
which uses the <em>global</em> <code>a</code> again and prints <code>a</code>'s value set in <code>main</code>.
Thus the output will be: <code>565</code>. A <em>local</em> variable is <em>only</em>
valid when we are executing the function in which it is defined.
Note that the <code>:=</code> used in line 12 is sometimes hard to spot so it is generally advised <em>not</em> to use
the same name for global and local variables.</p>

<h2 id="functions-as-values">Functions as values</h2>

<p><span class="index-ref" id="idxref:16-0"></span> <span class="index-ref" id="idxref:17-0"></span>
As with almost everything in Go, functions are also <em>just</em> values.
They can be assigned to variables as follows:</p>

<p>\lstinputlisting[label=src:anonfunc,linerange={3,}]{src/functions/anon-func.go}</p>

<p>Functions--as--values may be used in other places, for example maps.
Here we convert from integers to functions:</p>

<pre><code>var xs = map[int]func() int{
    1: func() int { return 10 },
    2: func() int { return 20 },
    3: func() int { return 30 },
}
</code></pre>

<p>Note that the final comma on second to last line is <em>mandatory</em>.</p>

<p>Or you can write a function that takes a function as its parameter, for
example a <code>Map</code> function that works on <code>int</code> slices. This is
left as an exercise for the reader; see the exercise (#map function).</p>

<h2 id="callbacks">Callbacks</h2>

<p>Because functions are values they are easy to pass to functions, from where
they can be used as callbacks. First define a function that
does &quot;something&quot; with an integer value:</p>

<pre><code>func printit(x int)
    fmt.Printf(&quot;%v\n&quot;, x)
}
</code></pre>

<p>This function does not return a value and just prints its argument. The <em>signature</em>
<span class="index-ref" id="idxref:18-0"></span>
of this function is: <code>func printit(int)</code>, or
without the function name: <code>func(int)</code>. To create a new function
that uses this one as a callback we need to use this signature:</p>

<pre><code>func callback(y int, f func(int)) {
    f(y)
}
</code></pre>

<p>Here we create a new function that takes two parameters: <code>y int</code>, i.e. just an <code>int</code>
and <code>f func(int)</code>, i.e. a function that takes an int and returns nothing. The parameter <code>f</code>
is the variable holding that function. It can be used as any other function, and we exectute the
function on line 2 with the parameter <code>y</code>: <code>f(y)</code></p>

<h2 id="deferred-code">Deferred Code</h2>

<p>Suppose you have a function in which you open a file and perform various
writes and reads on it. In such a function there are often spots where
you want to return early. If you do that, you will need to close the file
descriptor you are working on. This often leads to the following code:</p>

<pre><code>func ReadWrite() bool {
    file.Open(&quot;file&quot;)
    // Do your thing
    if failureX {
        file.Close() |\gocircle{1}|
    return false
    }

    if failureY {
    file.Close() |\gocircle{2}|
    return false
    }
    file.Close() |\gocircle{3}|
    return true  |\gocircle{4}|
}
</code></pre>

<p>Note that we repeat a lot of code here; you can see the that
<code>file.Close()</code> is called at \citemref{1}, \citemref{2}, and \citemref{3}.
To overcome this, Go has the <code>defer</code> <span class="index-ref" id="idxref:19-0"></span> keyword.
After <code>defer</code> you specify a function which is called just <em>before</em>
the current function exits.</p>

<p>With <code>defer</code> we can rewrite the above code as follows. It makes the function
more readable and it puts the <code>Close</code> <em>right next</em> to the <code>Open</code>.</p>

<pre><code>func ReadWrite() bool {
    file.Open(&quot;filename&quot;)
    defer file.Close() <span class="callout">1</span>
     Do your thing
    if failureX {
    return false <span class="callout">2</span>
    }
    if failureY {
    return false <span class="callout">3</span>
    }
    return true <span class="callout">4</span>
}
</code></pre>

<p>At <span class="callout">1</span> <code>file.Close()</code> is added to the defer list. <span class="index-ref" id="idxref:20-0"></span>
<code>Close</code> is now done automatically at <span class="callout">2</span> <span class="callout">3</span> <span class="callout">4</span>.
This makes the function shorter and more readable. It puts the <code>Close</code> right next to the <code>Open</code>.</p>

<p>You can put multiple functions on the &quot;defer list&quot;, like this example from <a class="cite" href="#effective_go"></a>:</p>

<pre><code>for i := 0; i &lt; 5; i++ {
    defer fmt.Printf(&quot;%d &quot;, i)
}
</code></pre>

<p>Deferred functions are executed in LIFO order, so the above code
prints: <code>4 3 2 1 0</code>.</p>

<p>With <code>defer</code> you can even change return values, provided that
you are using named result parameters and a function literal
<span class="index-ref" id="idxref:21-0"></span><sup class="footnote-ref" id="fnref:A-function-liter"><a class="footnote" href="#fn:A-function-liter">6</a></sup>, i.e:</p>

<pre><code>defer func() \{ /* ... */ \}()
</code></pre>

<p>Here we use a function without a name and specify the body of the function inline, basically
we're creating a nameless function on the spot. The final braces are needed because <code>defer</code>
needs a function call, not a function value. If our anonymous function would take an parameter
it would be easier to see why we need the braces:</p>

<pre><code>defer func(x int) \{ /* ... */ \(5)
</code></pre>

<p>In this (unnamed) function you can access any named return parameter:</p>

<pre><code>func f() (ret int)
    defer func() { //&lt;1&gt;
        ret++
    }()
    return 0
}
</code></pre>

<p>Here &lt;1&gt; we specify our function, the named return value <code>ret</code> is initialized with zero. The
nameless function in the defer increments the value of <code>ret</code> with 1. The <code>return 0</code> on line
5 <em>will not be the returned value</em>, because of <code>defer</code>. The function <code>f</code> will return 1!</p>

<h2 id="variadic-parameter">Variadic Parameter</h2>

<p>Functions that take a variable number of parameters are known as variadic functions.
<span class="index-ref" id="idxref:23-0"></span>
To declare a function as variadic, do something like this:</p>

<pre><code>func myfunc(arg ...int) {}
</code></pre>

<p>The <code>arg ...int</code> instructs Go to see this as a function that
takes a variable number of arguments. Note that these arguments all
have to have the type <code>int</code>. In the body of your function the variable
<code>arg</code> is a slice of ints:</p>

<pre><code>for _, n := range arg {
    fmt.Printf(&quot;And the number is: %d\n&quot;, n)
}
</code></pre>

<p>We range over the arguments on the first line. We are not interested in the index
as returned by <code>range</code>, hence the use of the underscore there. In the body of
the <code>range</code> we just print the parameters we were given.</p>

<p>If you don't specify the type of the variadic argument it defaults to the
empty interface <code>interface{}</code> (see Chapter <a href="#interfaces"></a>).</p>

<p>Suppose we have another variadic function called <code>myfunc2</code>, the
following example shows how to pass variadic arguments to it:</p>

<pre><code>func myfunc(arg ...int) {
    myfunc2(arg...)
    myfunc2(arg[:2]...)
}
</code></pre>

<p>With <code>myfunc2(arg...)</code> we pass all the parameters to <code>myfunc2</code>, but because the variadic
parameters is just a slice, we can use some slice tricks as well.</p>

<h2 id="panic-and-recovering">Panic and recovering</h2>

<p>Go does not have an exception mechanism: you cannot throw exceptions.
Instead it uses a panic-and-recover mechanism. It is worth remembering that you should use this as
a last resort, your code will not look, or be, better if it is littered with panics. It's a powerful tool:
use it wisely. So, how do you use it?
In the words of the Go Authors <a class="cite" href="#go_blog_panic"></a>:</p>

<dl>
<dt>Panic</dt>
<dd><p>is a built-in function that stops the ordinary flow of control and begins panicking. When the function
<code>F</code> calls <code>panic</code>, execution of <code>F</code> stops, any deferred functions in <code>F</code> are executed normally, and
then <code>F</code> returns to its caller. To the caller, <code>F</code> then
behaves like a call to <code>panic</code>. The process continues up the stack until all functions in the current
goroutine have returned, at which point the program crashes.
Panics can be initiated by invoking <code>panic</code> directly. They can also be caused by <em>runtime errors</em>, such
as out-of-bounds array accesses.</p></dd>

<dt>Recover</dt>
<dd><p>is a built-in function that regains control of a panicking goroutine. Recover is <em>only</em> useful inside
<em>deferred</em> functions. During normal execution, a call to <code>recover</code> will return <code>nil</code> and have no other effect.
If the current goroutine is panicking, a call
to <code>recover</code> will capture the value given to <code>panic</code> and resume normal execution.</p></dd>
</dl>

<p>This function checks if the function it gets as argument will panic when it is
executed<sup class="footnote-ref" id="fnref:Modified-from-a"><a class="footnote" href="#fn:Modified-from-a">7</a></sup>:</p>

<pre><code>func Panic(f func()) (b bool) { |\longremark{We define a new function `Panic` that takes %
a function as an argument (see \nref{sec:functions as values}). It returns true if `f` panics %
when run, else false;}|
    defer func() { |\longremark{We define a `defer` function that utilizes `recover`. If the %
current goroutine panics, this defer function will notice that. If `recover()` returns non-`nil` we set `b` %
to true;}|
        if x := recover(); x != nil {
            b = true
        }
    }()
    f() |\longremark{Execute the function we received as the argument;}|
    return |\longremark{Return the value of `b`. Because `b` is a named return parameter.}|
}
</code></pre>

<p>The following code fragment, shows how we can use this function:</p>

<pre><code>func panicy() {
    var a []int
    a[3] = 5
}

func main() {
    fmt.Println(Panic(panicy))
}
</code></pre>

<p>On line 3 the <code>a[3] = 5</code> triggers a <em>runtime</em> out of bounds error which results in a panic. Thus
this program will print <code>true</code>.
If we change line 2: <code>var a []int</code> to <code>var a [3]int</code> the function <code>panicy</code> does not panic
anymore. Why?</p>

<h2 id="exercises-1">Exercises</h2>

<h1 id="bibliography" class="appendix bibliography">Bibliography</h1>
<div class="bibliography">
<div class="bibliography-item">
  <span class="biblography-id" id="go_nuts">[1]</span>
  Go Community. Go Nuts mailing list. <a href="http://groups.google.com/group/golang-nuts">http://groups.google.com/group/golang-nuts</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_blog">[2]</span>
  Go Authors. The Go programming language blog. <a href="http://blog.golang.org/">http://blog.golang.org/</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="c">[3]</span>
  Brian Kernighan Dennis Ritchie. The C programming language. <a href=""></a>
  1975.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="perl">[4]</span>
  Larry Wall et al. Perl. <a href="http://perl.org/">http://perl.org/</a>
  1987.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="limbo">[5]</span>
  Plan 9 Authors. Limbo. <a href="http://www.vitanuova.com/inferno/papers/limbo.html">http://www.vitanuova.com/inferno/papers/limbo.html</a>
  1995.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_web">[6]</span>
  Go Authors. Go website. <a href="http://golang.org/">http://golang.org/</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="duck_typing">[7]</span>
  Wikipedia. Duck typing. <a href="http://en.wikipedia.org/wiki/Duck_typing">http://en.wikipedia.org/wiki/Duck_typing</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="bubblesort">[8]</span>
  Wikipedia. Bubble sort. <a href="http://en.wikipedia.org/wiki/Bubble_sort">http://en.wikipedia.org/wiki/Bubble_sort</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="inferno">[9]</span>
  Inferno Authors. Inferno. <a href="http://www.vitanuova.com/inferno/">http://www.vitanuova.com/inferno/</a>
  1995.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="Newsqueak">[10]</span>
  Rob Pike. Newsqueak: a language for communicating with mice. <a href="http://swtch.com/~rsc/thread/newsqueak.pdf">http://swtch.com/~rsc/thread/newsqueak.pdf</a>
  1989.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_faq">[11]</span>
  Go Authors. Go faq. <a href="http://golang.org/doc/go_faq.html">http://golang.org/doc/go_faq.html</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_spec">[12]</span>
  Go Authors. Go language specification. <a href=" http://golang.org/doc/go_spec.html"> http://golang.org/doc/go_spec.html</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_interfaces">[13]</span>
  Ian Lance Taylor. Go interfaces. <a href="http://www.airs.com/blog/archives/277">http://www.airs.com/blog/archives/277</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="RFC1196">[14]</span>
  D. Zimmerman. The finger user information protocol. <a href="http://www.ietf.org/rfc/rfc1196.txt">http://www.ietf.org/rfc/rfc1196.txt</a>
  1990.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="fizzbuzz">[15]</span>
  Imran On Tech. Using fizzbuzz to find developers.... <a href=""></a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_blog_panic">[16]</span>
  Go Authors. Defer, panic, and recover. <a href=""></a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="C++">[17]</span>
  Bjarne Stroustrup. The C++ programming language. <a href=""></a>
  1983.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="iota">[18]</span>
  Wikipedia. Iota. <a href="http://en.wikipedia.org/wiki/Iota">http://en.wikipedia.org/wiki/Iota</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_course_day2">[19]</span>
  Rob Pike. The Go programming language, day 2. <a href="http://golang.org/doc/GoCourseDay2.pdf">http://golang.org/doc/GoCourseDay2.pdf</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_release_hist">[20]</span>
  Go Authors. Go release history. <a href="http://golang.org/doc/devel/release.html">http://golang.org/doc/devel/release.html</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_issue_65">[21]</span>
  Go Community. Go issue 65: compiler can't spot guaranteed return in if statement. <a href=""></a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="RFC4627">[22]</span>
  D. Crockford. The application/json media type for javascript object notation (json). <a href="http://www.ietf.org/rfc/rfc4627.txt">http://www.ietf.org/rfc/rfc4627.txt</a>
  2006.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_tutorial">[23]</span>
  Go Authors. Go tutorial. <a href="http://golang.org/doc/go_tutorial.html">http://golang.org/doc/go_tutorial.html</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_intro">[24]</span>
  Mark C. Chu-Carroll. Google's new language: Go. <a href="http://scienceblogs.com/goodmath/2009/11/googles_new_language_go.php">http://scienceblogs.com/goodmath/2009/11/googles_new_language_go.php</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_cpp">[25]</span>
  Go Authors. Go for C++ programmers. <a href="http://golang.org/doc/go_for_cpp_programmers.html">http://golang.org/doc/go_for_cpp_programmers.html</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="java">[26]</span>
  James Gosling et al. Java. <a href="http://oracle.com/java/">http://oracle.com/java/</a>
  1995.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="perl-packages">[27]</span>
  Perl Package Authors. Comprehensive perl archive network. <a href="http://cpan.org/">http://cpan.org/</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="plan9">[28]</span>
  Plan 9 Authors. Plan 9. <a href="http://plan9.bell-labs.com/plan9/index.html">http://plan9.bell-labs.com/plan9/index.html</a>
  1992.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="csp">[29]</span>
  Wikipedia. Communicating sequential processes. <a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes">http://en.wikipedia.org/wiki/Communicating_sequential_processes</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_youtube">[30]</span>
  Go Authors. Go youtube channel. <a href="http://youtube.com/gocoding/">http://youtube.com/gocoding/</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="Hoare">[31]</span>
  C. A. R. Hoare. Communicating sequential processes (csp). <a href="http://www.usingcsp.com/cspbook.pdf">http://www.usingcsp.com/cspbook.pdf</a>
  1985.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_course_day3">[32]</span>
  Rob Pike. The Go programming language, day 3. <a href="http://golang.org/doc/GoCourseDay3.pdf">http://golang.org/doc/GoCourseDay3.pdf</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_profiling">[33]</span>
  Russ Cox. Profiling Go programs. <a href="http://blog.golang.org/2011/06/profiling-go-programs.html">http://blog.golang.org/2011/06/profiling-go-programs.html</a>
  2011.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="RFC4641">[34]</span>
  Kolkman & Gieben. Dnssec operational practices. <a href="http://www.ietf.org/rfc/rfc4641.txt">http://www.ietf.org/rfc/rfc4641.txt</a>
  2006.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="effective_go">[35]</span>
  Go Authors. Effective Go. <a href="http://golang.org/doc/effective_go.html">http://golang.org/doc/effective_go.html</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_install">[36]</span>
  Go Authors. Getting Started. <a href="http://golang.org/doc/install/">http://golang.org/doc/install/</a>
  2012.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="erlang">[37]</span>
  Ericsson Cooperation. Erlang. <a href="http://www.erlang.se/">http://www.erlang.se/</a>
  1986.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="scala">[38]</span>
  LAMP Group at EPFL. Scala. <a href=""></a>
  2003.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="haskell">[39]</span>
  Haskell Authors. Haskell. <a href="http://www.haskell.org/">http://www.haskell.org/</a>
  1990.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="quicksort">[40]</span>
  C. A. R. Hoare. Quicksort. <a href="http://en.wikipedia.org/wiki/Quicksort">http://en.wikipedia.org/wiki/Quicksort</a>
  1960.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_doc">[41]</span>
  Go Authors. Go package documentation. <a href="http://golang.org/doc/pkg/">http://golang.org/doc/pkg/</a>
  2010.
</div>
<div class="bibliography-item">
  <span class="biblography-id" id="go_nuts_interfaces">[42]</span>
  Go Community. Function accepting a slice of interface types. <a href=""></a>
  2010.
</div>
</div>

<h1 id="footnotes" class="appendix footnotes">Footnotes</h1>
<div class="footnotes">

<ol>
<li id="fn:Yes-that-sounds">Yes, that sounds a lot like <em>co</em>routines, but goroutines are slightly different as we will see in Chapter <a href="#chap:channels"></a>.</li>
<li id="fn:http-play-golang"><a href="http://play.golang.org">http://play.golang.org</a>.</li>
<li id="fn:http-golang-org"><a href="http://golang.org/doc/">http://golang.org/doc/</a> itself is served by <code>godoc</code>.</li>
<li id="fn:When-building-fr">When building from source it must be installed separately with <code>go get golang.org/x/tools/cmd/godoc</code>.</li>
<li id="fn:This-is-a-motto">This is a motto of Go; &quot;Do <em>more</em> with <em>less</em> code&quot;.</li>
<li id="fn:A-function-liter">A function literal is sometimes called a closure <span class="index-ref" id="idxref:24-1"></span>.</li>
<li id="fn:Modified-from-a">Modified from a presentation of Eleanor McHugh.</li>
</ol>
</div>
<div class="index">

<h1 id="index-ref-index" class="appendix index">Index</h1>
<h3 class="index-ref-char">b</h3>
<span class="index-ref-primary">built-in</span>
<span class="index-ref-secondary">append</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:8-0">1</a>
<span class="index-ref-secondary">copy</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:9-0">1</a>
<h3 class="index-ref-char">c</h3>
<span class="index-ref-primary">closure</span>
<span class="index-ref-secondary"></span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:22-0">1</a>,<a class="index-ref-ref" href="#idxref:24-1">2</a>
<span class="index-ref-secondary"></span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:1-0">1</a>
<h3 class="index-ref-char">f</h3>
<span class="index-ref-primary">functions</span>
<span class="index-ref-secondary">named return parameters</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:13-0">1</a>
<span class="index-ref-secondary">signature</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:18-0">1</a>
<span class="index-ref-secondary">literal</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:21-0">1</a>
<span class="index-ref-secondary">receiver</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:10-0">1</a>
<span class="index-ref-secondary">pass-by-value</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:12-0">1</a>
<span class="index-ref-secondary">method</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:11-0">1</a>
<span class="index-ref-secondary">literals</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:17-0">1</a>
<span class="index-ref-secondary">variadic</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:23-0">1</a>
<span class="index-ref-secondary">as values</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:16-0">1</a>
<h3 class="index-ref-char">g</h3>
<span class="index-ref-primary">goroutines</span>
<span class="index-ref-secondary"></span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:0-0">1</a>
<h3 class="index-ref-char">k</h3>
<span class="index-ref-primary">keywords</span>
<span class="index-ref-secondary">defer</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:19-0">1</a>
<span class="index-ref-secondary">defer list</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:20-0">1</a>
<h3 class="index-ref-char">r</h3>
<span class="index-ref-primary">reference types</span>
<span class="index-ref-secondary"></span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:5-0">1</a>
<h3 class="index-ref-char">s</h3>
<span class="index-ref-primary">scope</span>
<span class="index-ref-secondary">local</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:14-0">1</a>,<a class="index-ref-ref" href="#idxref:15-1">2</a>
<span class="index-ref-secondary">capacity</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:6-0">1</a>
<span class="index-ref-secondary">length</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:7-0">1</a>
<h3 class="index-ref-char">t</h3>
<span class="index-ref-primary">tooling</span>
<span class="index-ref-secondary">go</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:2-0">1</a>
<span class="index-ref-secondary">go run</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:4-0">1</a>
<span class="index-ref-secondary">go build</span><span class="index-ref-space"> </span><a class="index-ref-ref" href="#idxref:3-0">1</a>
</div>
</body>
</html>
